# Perfect Timing and Latency

One of the strengths of the Web Audio API as compared to the <audio> tag is that it comes with a low-latency precise-timing model.
Low latency is very important for games and other interactive applications since you often need fast auditory(å¬è§‰çš„ï¼Œå¬åŠ›çš„) response to user actions. If the feedback is not immediate, the user will sense the delay, which will lead to frustration. In practice, due to imperfections of human hearing, there is leeway for a delay of up to 20 ms or so, but the number varies depending on many factors.
Precise timing enables you to schedule events at specific times in the future. This is very important for scripted scenes and musical applications.

# å®Œç¾çš„æ—¶æœºå’Œå»¶è¿Ÿ

ç›¸è¾ƒäº <audio> æ ‡ç­¾ Web Audio API æ‹¥æœ‰ä½å»¶è¿Ÿç²¾ç¡®å®šæ—¶æ¨¡å‹ã€‚ 

ä½å»¶æ—¶å¯¹äºæ¸¸æˆæˆ–äº¤äº’å¼åº”ç”¨æ¥è¯´éå¸¸é‡è¦ï¼Œå› ä¸ºäº¤äº’æ“ä½œæ—¶è¦å¿«é€Ÿå“åº”ç»™ç”¨æˆ·å¬è§‰ã€‚å¦‚æœå“åº”çš„ä¸åŠæ—¶ï¼Œç”¨æˆ·å°±ä¼šå¯Ÿè§‰åˆ°å»¶æ—¶è¿™ç§ä½“éªŒç›¸å½“ä¸å¥½ã€‚

åœ¨å®è·µä¸­ï¼Œç”±äºäººç±»å¬è§‰çš„ä¸å®Œç¾ï¼Œå»¶è¿Ÿçš„ä½™åœ°å¯è¾¾20æ¯«ç§’å·¦å³ï¼Œä½†å…·ä½“å»¶è¿Ÿå¤šå°‘å–å†³äºè®¸å¤šå› ç´ ã€‚ç²¾ç¡®çš„å¯æ§æ—¶é—´ä½¿å¾—èƒ½å¤Ÿåœ¨æœªæ¥çš„ç‰¹å®šæ—¶é—´å®‰æ’äº‹ä»¶ã€‚è¿™å¯¹äºè„šæœ¬åœºæ™¯å’ŒéŸ³ä¹åº”ç”¨æ¥è¯´éå¸¸é‡è¦

## Timing Model
One of the key things that the audio context provides is a consistent timing model and frame of reference for time. Importantly, this model is different from the one used for JavaScript timers such as setTimeout, setInterval, and new Date(). It is also different from the performance clock provided by window.performance.now().

All of the absolute times that you will be dealing with in the Web Audio API are in seconds (not milliseconds!), in the coordinate system of the specified audio context. The current time can be retrieved from the audio context via the currentTime property. Although the units are seconds, time is stored as a floating-point value with high precision.




## æ—¶é—´æ¨¡å‹
å…¶ä¸­ä¸€ä¸ªé‡è¦çš„ç‚¹æ˜¯ï¼ŒéŸ³é¢‘ä¸Šä¸‹æ–‡æä¾›äº†ä¸€è‡´çš„è®¡æ—¶æ¨¡å‹å’Œæ—¶é—´çš„å¸§ç‡ã€‚é‡è¦çš„æ˜¯æ­¤æ¨¡å‹æœ‰åˆ«äºæˆ‘ä»¬å¸¸ç”¨çš„ Javascript è„šæœ¬æ‰€ç”¨çš„è®¡æ—¶å™¨ å¦‚ setTimeout, setInterval, new Date()ã€‚ä¹Ÿæœ‰åˆ«äº window.performance.now()æä¾›çš„æ€§èƒ½åˆ†ææ—¶é’Ÿ

åœ¨ Web Audio API éŸ³é¢‘ä¸Šä¸‹æ–‡ç³»ç»Ÿåæ ‡ä¸­æ‰€æœ‰ä½ æ‰“äº¤é“çš„çš„ç»å¯¹æ—¶é—´å•ä½æ˜¯ç§’è€Œä¸æ˜¯æ¯«ç§’ã€‚å½“å‰æ—¶é—´å¯é€šè¿‡éŸ³é¢‘ä¸Šä¸‹æ–‡çš„ currentTime å±æ€§è·å–ã€‚åŒæ ·å®ƒä¹Ÿæ˜¯ç§’ä¸ºå•ä½ï¼Œæ—¶é—´å­˜å‚¨ä¸ºé«˜ç²¾åº¦çš„æµ®ç‚¹æ•°å­˜å‚¨ã€‚




## Precise Playback and Resume
The start() function makes it easy to schedule precise sound playback for games and other time-critical applications. To get this working properly, ensure that your sound buffers are pre-loaded [see â€œLoading and Playing Soundsâ€ on page 10]. Without a pre-loaded buffer, you will have to wait an unknown amount of time for the browser to fetch the sound file, and then for the Web Audio API to decode it. The failure mode in this case is you want to play a sound at a precise instant, but the buffer is still loading or decoding.

Sounds can be scheduled to play at a precise time by specifying the first (when) parameter of the start() call. This parameter is in the coordinate system of the AudioContextâ€™s currentTime. If the parameter is less than the currentTime, it is played immediately. Thus start(0) always plays sound immediately, but to schedule sound in 5 seconds, you would call start(context.currentTime + 5).

Sound buffers can also be played from a specific time offset by specifying a second parameter to the start() call, and limited to a specific duration with a third optional parameter. For example, if we want to pause a sound and play it back from the paused position, we can implement a pause by tracking the amount of time a sound has been playing in the current session and also tracking the last offset in order to resume later:

Once a source node has finished playing back, it canâ€™t play back more. To play back the underlying buffer again, you need to create a new source node (AudioBufferSourceNode) and call start():


Though recreating the source node may seem inefficient at first, keep in mind that source nodes are heavily optimized for this pattern. Remember that if you keep a handle to the AudioBuffer, you donâ€™t need to make another request to the asset to play the same sound again. By having this AudioBuffer around, you have a clean sepâ€ aration between buffer and player, and can easily play back multiple versions of the same buffer overlapping in time. If you find yourself needing to repeat this pattern,

encapsulate playback with a simple helper function like playSound(buffer) in an earlier code snippet.

## ç²¾ç¡®çš„æ’­æ”¾ä¸å¤æ’­

åœ¨æ¸¸æˆæˆ–å…¶å®ƒéœ€è¦ç²¾ç¡®æ—¶é—´æ§åˆ¶çš„åº”ç”¨ä¸­ start() æ–¹æ³•ç”¨äºæ§åˆ¶å®‰æ’ç²¾ç¡®çš„æ’­æ”¾ã€‚ä¸ºäº†ä¿è¯æ­£ç¡®è¿è¡Œï¼Œéœ€è¦ç¡®ä¿ç¼“å†²å·²æå‰åŠ è½½ã€‚å¦‚æœæ²¡æœ‰æå‰ç¼“å†²å¥½ã€‚ä¸ºäº† Web Audio API èƒ½è§£ç ï¼Œå¦‚æœæ²¡æœ‰æå‰åŠ è½½é‚£ä¹ˆéœ€è¦ç­‰ç­‰æµè§ˆå™¨å®ŒæˆåŠ è½½éŸ³é¢‘æ–‡ä»¶ã€‚å¦‚æœæ²¡æœ‰åŠ è½½å¥½æˆ–è§£ç å¥½å°±å»æ’­æ”¾æˆ–ç²¾å‡†çš„æ§åˆ¶æ’­æ”¾é‚£ä¹ˆå¯èƒ½ä¼šå¤±è´¥ã€‚

start() æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ç”¨äºå£°éŸ³ç²¾ç¡®å®šä½æ§åˆ¶åœ¨å“ªé‡Œå¼€å§‹æ’­æ”¾ã€‚æ­¤å‚æ•°æ˜¯ AudioContext éŸ³é¢‘ä¸Šä¸‹æ–‡åæ ‡ç³»å†…çš„ currentTime, å¦‚æœä¼ å‚å°äº currentTIme, åˆ™å®ƒä¼šç«‹å³æ’­æ”¾ã€‚å› ä¸º start(0) å°±æ˜¯ç›´æ¥å¼€å§‹æ’­æ”¾çš„æ„æ€ ï¼Œå¦‚æœæƒ³è¦æ§åˆ¶åœ¨ 5 ç§’åæ’­æ”¾ï¼Œåˆ™éœ€è¦ start(context.currentTime + 5)ã€‚

å£°éŸ³çš„ç¼“å†²ä¹Ÿå¯ä»¥ä»ç‰¹å®šä½ç½®å¼€å§‹æ’­æ”¾ï¼Œä½¿ç”¨ start() æ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°æ§åˆ¶ï¼Œç¬¬ä¸‰ä¸ªå¯é€‰å‚æ•°ç”¨äºæ—¶é•¿ç‰¹æ®Šé™åˆ¶ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬æƒ³æš‚åœååœ¨æš‚åœçš„ä½ç½®é‡æ–°å¼€å§‹æ¢å¤æ’­æ”¾ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ç»Ÿè®¡å£°éŸ³åœ¨å½“å‰ session æ’­æ”¾äº†å¤šä¹…å¹¶è¿½è¸ªåç§»é‡ç”¨äºåé¢æ¢å¤æ’­æ”¾


```
// å‡å®š context æ˜¯ç½‘é¡µ audio context ä¸Šä¸‹æ–‡
var startOffset = 0; 
var startTime = 0;
function pause() {
  source.stop();
  // è®¡ç®—è·ç¦»ä¸Šæ¬¡æš‚åœæ—¶è¿‡å»äº†å¤šä¹…
  startOffset += context.currentTime - startTime;
}
```

ä¸€æ—¦æºèŠ‚ç‚¹æ’­æ”¾å®Œæ¯•ï¼Œå®ƒæ— æ³•å†é‡æ’­ã€‚ä¸ºäº†é‡æ’­åº•å±‚çš„ç¼“å†²åŒºï¼Œä½ éœ€è¦æ–°å»ºä¸€ä¸ªæ–°çš„ æºèŠ‚ç‚¹(AudioBufferSourceNode) å¹¶è°ƒç”¨ start():

```
function play() {
  startTime = context.currentTime;
  var source = context.createBufferSource();
  // Connect graph
  source.buffer = this.buffer;
  source.loop = true;
  source.connect(context.destination);
  // å¼€å§‹æ’­æ”¾ï¼Œä½†ç¡®ä¿æˆ‘ä»¬é™å®šåœ¨ buffer ç¼“å†²åŒºçš„èŒƒå›´å†… 
  source.start(0, startOffset % buffer.duration);
  
}
```

å°½ç®¡é‡æ–°æ–°å»ºä¸€ä¸ªæºèŠ‚ç‚¹çœ‹èµ·æ¥éå¸¸çš„ä½æ•ˆï¼Œç‰¢è®°ï¼Œè¿™ç§æ¨¡å¼ä¸‹æºèŠ‚ç‚¹è¢«ç€é‡ä¼˜åŒ–è¿‡äº†ã€‚è¯·è®°ä½ï¼Œå¦‚æœä½ åœ¨å¤„ç† AudioBufferï¼Œ æ’­æ”¾åŒä¸€ä¸ªå£°éŸ³ä½ æ— éœ€é‡æ–°è¯·æ±‚èµ„æºã€‚å½“æœ‰äº†  AudioBuffer, ç¼“å†²åŒºä¸æ’­æ”¾è¢«åŒºåˆ†çš„å¾ˆæ˜ç¡®ï¼ŒåŒä¸€æ—¶é—´å†…å¯ä»¥æ’­æ”¾ä¸åŒç‰ˆæœ¬çš„ç¼“å†²åŒºã€‚å¦‚æœä½ æ„Ÿè§‰éœ€è¦é‡å¤è¿™æ ·çš„æ–¹å¼è°ƒç”¨ ï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨å°†å®ƒå°è£…æˆä¸€ä¸ªç®€å•çš„æ–¹æ³•å‡½æ•°æ¯”å¦‚ playSound(buffer) å°±åƒåœ¨ç¬¬ä¸€ç« ä»£ç ç‰‡æ–­ä¸­æœ‰æåˆ°è¿‡çš„ã€‚





## Scheduling Precise Rhythms
The Web Audio API lets developers precisely schedule playback in the future. To demonstrate this, letâ€™s set up a simple rhythm track. Probably the simplest and most widely known drumkit pattern is shown in Figure 2-1, in which a hihat is played every eighth note, and the kick and snare are played on alternating quarter notes, in 4/4 time.

Assuming we have already loaded the kick, snare, and hihat buffers, the code to do this is simple:

Once youâ€™ve scheduled sound in the future, there is no way to unschedule that future playback event, so if you are dealing with an application that quickly changes, scheduling sounds too far into the future is not advisable. A good way of dealing with this problem is to create your own scheduler using JavaScript timers and an event queue. This approach is described in A Tale of Two Clocks.

## è§„åˆ’ç²¾ç¡®çš„èŠ‚å¥

Web Audio API å…è®¸å¼€å‘äººå‘˜åœ¨ç²¾ç¡®åœ°è§„åˆ’æ’­æ”¾ã€‚ä¸ºäº†æ¼”ç¤ºï¼Œè®©æˆ‘ä»¬å…ˆè®¾ç½®ä¸€ä¸ªç®€å•çš„èŠ‚å¥è½¨é“ã€‚ä¹Ÿè®¸æœ€ç®€å•çš„è¦å±å¹¿ä¸ºäººçŸ¥çš„ çˆµå£«é¼“æ¨¡å¼ï¼ˆdrumkit patternï¼‰ å¦‚å›¾ 2-1ï¼Œhihat æ¯8ä¸ªéŸ³ç¬¦æ¼”å¥ä¸€æ¬¡ï¼Œkick å’Œ snare åœ¨å››åˆ†éŸ³ç¬¦ä¸Šäº¤æ›¿æ¼”å¥

>æ³¨ï¼š kick æ˜¯åº•é¼“ï¼Œå°±æ˜¯æ¶å­é¼“ç»„é‡Œé¢æœ€ä¸‹é¢æœ€å¤§çš„é‚£ä¸ªé¼“ï¼Œå£°éŸ³æ˜¯å’šå’šå’šçš„ï¼›
>
>hihatæ˜¯é¼“æ‰‹å·¦è¾¹ä¸¤ç‰‡åˆåœ¨ä¸€èµ·çš„é•²ç‰‡ é—­é•² æ˜¯æ¬¡æ¬¡æ¬¡çš„å£°éŸ³ï¼Œå¼€é•²æ˜¯æ“¦æ“¦æ“¦çš„å£°éŸ³
>
>snare æ˜¯ç¦»é¼“æ‰‹æœ€è¿‘çš„å¹³æ”¾çš„å°é¼“ï¼Œå«å†›é¼“ï¼Œæ‰“ä¸Šå»æ˜¯å’”å’”å’”çš„å£°éŸ³ï¼›


> æ³¨ï¼šå…«åˆ†éŸ³ç¬¦åœ¨ä¹æ›²ä¸­é€šå¸¸ç”¨äºè¡¨ç¤ºå¿«é€Ÿã€è½»å¿«çš„èŠ‚å¥ã€‚ç”±äºå…«åˆ†éŸ³ç¬¦çš„æ—¶å€¼æ˜¯å…¨éŸ³ç¬¦çš„ä¸€åŠï¼Œæ‰€ä»¥å®ƒå¯ä»¥è®©éŸ³ä¹å¬èµ·æ¥æ›´åŠ æ´»æ³¼ã€æœ‰æ´»åŠ›ğŸ˜‰ æ¯”å¦‚åœ¨ä¸€äº›å¿«èŠ‚å¥çš„æ‘‡æ»šä¹ã€çˆµå£«ä¹æˆ–æµè¡ŒéŸ³ä¹ä¸­ï¼Œå…«åˆ†éŸ³ç¬¦çš„ä½¿ç”¨éå¸¸æ™®éã€‚

![images](./ch02/img/2-1.jpg)

å‡å®šæˆ‘ä»¬å·²é”å®šäº† kick, snare,å’Œ hihat ç¼“å†²ï¼Œé‚£ä¹ˆä»£ç å®ç°å°±æ¯”è¾ƒç®€å•ï¼š

```
for (var bar = 0; bar < 2; bar++) {
  var time = startTime + bar * 8 * eighthNoteTime; 
  // Play the bass (kick) drum on beats 1, 5 
  playSound(kick, time);
  playSound(kick, time + 4 * eighthNoteTime);
  // Play the snare drum on beats 3, 7
  playSound(snare, time + 2 * eighthNoteTime);
  playSound(snare, time + 6 * eighthNoteTime);
  // Play the hihat every eighth note.
  for (var i = 0; i < 8; ++i) {
    playSound(hihat, time + i * eighthNoteTime);
  } 
}
```

ä»£ç ä¸­å¯¹æ—¶é—´è¿›è¡Œç¡¬ç¼–ç æ˜¯ä¸æ˜æ™ºçš„ã€‚æ‰€ä»¥å¦‚æœä½ æ­£åœ¨å¤„ç†ä¸€ä¸ªå¿«é€Ÿå˜åŒ–çš„åº”ç”¨ç¨‹åºï¼Œé‚£æ˜¯ä¸å¯å–çš„ã€‚å¤„ç†æ­¤é—®é¢˜çš„ä¸€ä¸ªå¥½æ–¹æ³•æ˜¯ä½¿ç”¨JavaScriptè®¡æ—¶å™¨å’Œäº‹ä»¶é˜Ÿåˆ—åˆ›å»ºè‡ªå·±çš„è°ƒåº¦å™¨ã€‚è¿™ç§æ–¹æ³•åœ¨ã€ŠåŒé’Ÿçš„æ•…äº‹ã€‹ä¸­æœ‰æè¿°

>ã€ŠåŒé’Ÿçš„æ•…äº‹ã€‹å³ ã€ŠA Tale of Two Clocksã€‹ å¯“è¨€æ•…äº‹å¤§è‡´å‘Šè¯‰äººä»¬ä¸èƒ½ä¾é å•ç‹¬ä¸€ç§æ–¹å¼ï¼Œéœ€è¦ä¾é å¤šç§æ–¹å¼æ–¹æ³•è§£å†³é—®é¢˜

## Changing Audio Parameters
Many types of audio nodes have configurable parameters. For example, the GainNode has a gain parameter that controls the gain multiplier for all sounds going through the node. Specifically, a gain of 1 does not affect the amplitude, 0.5 halves it, and 2 doubles it [see â€œVolume, Gain, and Loudnessâ€ on page 21]. Letâ€™s set up a graph as follows:


In the context of the API, audio parameters are represented as AudioParam instances. The values of these nodes can be changed directly by setting the value attribute of a param instance:



## æ›´æ”¹éŸ³é¢‘å‚æ•°

å¾ˆå¤šéŸ³é¢‘èŠ‚ç‚¹ç±»å½¢çš„å‚æ•°éƒ½æ˜¯å¯é…çš„ã€‚ä¸¾ä¸ªä¾‹å­ï¼ŒGainNode æ‹¥æœ‰ gain å‚æ•°ç”¨äºæ§åˆ¶é€šè¿‡ gain èŠ‚ç‚¹çš„æ‰€æœ‰å£°éŸ³éŸ³é‡ä¹˜æ•°ã€‚ç‰¹åˆ«çš„ä¸€ç‚¹å‚æ•°å¦‚æœæ˜¯1åˆ™ä¸å½±å“å¹…åº¦ï¼Œ0.5 é™ä¸€åŠï¼Œ2 åˆ™æ˜¯åŒå€ã€‚è®©æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªï¼š

>æ³¨ï¼š gainèŠ‚ç‚¹æˆ–ç§°å¢ç›ŠèŠ‚ç‚¹é€šå¸¸ç”¨äºè°ƒèŠ‚éŸ³é¢‘ä¿¡å·çš„éŸ³é‡

```
  // åˆ›å»º gain node.
  var gainNode = context.createGain();
  // è¿æ¥  source åˆ° gain node. 
  source.connect(gainNode);
  // è¿æ¥  gain node è‡³  destination. 
  gainNode.connect(context.destination);
```

åœ¨ context API ä¸­ï¼ŒéŸ³é¢‘å‚æ•°ç”¨éŸ³é¢‘å®ä¾‹è¡¨ç¤ºã€‚è¿™äº›å€¼å¯é€šè¿‡èŠ‚ç‚¹ç›´æ¥å˜æ›´ï¼š

```
// å‡å°éŸ³é‡
gainNode.gain.value = 0.5;
```


The values can also be changed later, via precisely scheduled parameter changes in the future. We could also use setTimeout to do this scheduling, but this is not precise for several reasons:

1. Millisecond-based timing may not be enough precision.
2. The main JS thread may be busy with high-priority tasks like page layout, garbage collection, and callbacks from other APIs, which delays timers.
3. The JS timer is affected by tab state. For example, interval timers in backgrounâ€ ded tabs fire more slowly than if the tab is in the foreground.

Instead of setting the value directly, we can call the setValueAtTime() function, which takes a value and a start time as arguments. For example, the following snippet sets the gain value of a GainNode in one second:

å½“ç„¶ä¹Ÿå¯ä»¥æ™šä¸€ç‚¹ä¿®æ”¹å€¼ï¼Œé€šè¿‡ç²¾ç¡®å®‰æ’åœ¨åç»­æ›´æ”¹ã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨  setTimeout æ¥å»¶æ—¶ä¿®æ”¹ï¼Œä½†å®ƒä¸å¤Ÿç²¾ç¡®ï¼ŒåŸå› æœ‰å‡ ç‚¹ï¼š

1. æ¯«ç§’åŸºæ•°çš„è®¡æ—¶å¯èƒ½ä¸å¤Ÿç²¾ç¡®
2. ä¸» JS è¿›ç¨‹å¯èƒ½å¾ˆå¿™éœ€è¦å¤„ç†æ›´é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡æ¯”å¦‚é¡µé¢å¸ƒå±€ï¼Œåƒåœ¾å›æ”¶ä»¥åŠå…¶å®ƒ API å¯èƒ½å¯¼è‡´å»¶æ—¶çš„å›è°ƒå‡½æ•°é˜Ÿåˆ—ç­‰
3. JS è®¡æ—¶å™¨å¯èƒ½ä¼šå—åˆ°æµè§ˆå™¨ tab çš„çŠ¶æ€å½±å“ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œinterval è®¡æ—¶å™¨ç›¸æ¯”äº tab åœ¨å‰å°è¿è¡Œæ—¶ï¼Œtab åœ¨åå°è¿è¡Œæ—¶è§¦å‘çš„æ›´æ…¢

æˆ‘ä»¬å¯ä»¥ç›´æ¥è°ƒç”¨  setValueAtTime() æ–¹æ³•æ¥ä»£æ›¿ç›´æ¥è®¾å€¼ï¼Œå®ƒéœ€è¦ä¸€ä¸ªå€¼ä¸å¼€å§‹æ—¶é—´ä½œä¸ºå‚æ•°ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä¸‹é¢çš„ä»£ç ç‰‡æ–­ä¸€ç§’å°±æå®šäº† GainNodeçš„ gain å€¼è®¾ç½®

```
gainNode.gain.setValueAtTime(0.5, context.currentTime + 1);
```


## Gradually Varying Audio Parameters
In many cases, rather than changing a parameter abruptlyï¼ˆçªç„¶åœ°ï¼›å”çªåœ°ï¼‰, you would prefer a more gradual change. For example, when building a music player application, we want to fade the current track out, and fade the new one in, to avoid a jarringï¼ˆä¸å’Œè°çš„ï¼‰ transition. While you can achieve this with multiple calls to setValueAtTime as described previously, this is inconvenient.

The Web Audio API provides a convenient set of RampToValue methods to gradually change the value of any parameter. These functions are linearRampToValueAtTime() and exponentialRampToValueAtTime(). The difference between these two lies in the way the transition happens. In some cases, an exponential transition makes more sense, since we perceiveï¼ˆè®¤ä¸ºï¼Œç†è§£ï¼›å¯Ÿè§‰ï¼Œæ³¨æ„åˆ°ï¼›æ„è¯†åˆ°ï¼‰ many aspects of sound in an exponential manner.

Letâ€™s take an example of scheduling a crossfade in the future. Given a playlist, we can transition between tracks by scheduling a gain decrease on the currently playing track, and a gain increase on the next one, both slightly before the current track finishes playing:


## æ¸å˜çš„éŸ³é¢‘å‚æ•°
åœ¨å¾ˆå¤šä¾‹å­ä¸­ï¼Œç›¸è¾ƒäºç›´æ¥ç¡¬ç”Ÿç”Ÿè®¾ç½®ä¸€ä¸ªå‚æ•°ï¼Œä½ å¯èƒ½æ›´å€¾å‘äºæ¸å˜è®¾å€¼ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå½“å¼€å‘éŸ³ä¹åº”ç”¨æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›å½“å‰çš„å£°éŸ³è½¨é“æ¸éšï¼Œç„¶åæ–°çš„å£°éŸ³è½¨é“æ¸å…¥è€Œé¿å…ç”Ÿç¡¬çš„åˆ‡æ¢ã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥åˆ©ç”¨å¤šæ¬¡è°ƒç”¨ setValueAtTime å‡½æ•°çš„æ–¹æ³•å®ç°ç±»ä¼¼çš„æ•ˆæœï¼Œä½†æ˜¾ç„¶è¿™ç§æ–¹æ³•ä¸å¤ªæ–¹ä¾¿ã€‚

Web Audio API æä¾›äº†ä¸€ä¸ªå †æ–¹ä¾¿çš„ RampToValue æ–¹æ³•ï¼Œèƒ½å¤Ÿæ¸å˜ä»»ä½•å‚æ•°ã€‚ å®ƒä»¬æ˜¯ linearRampToValueAtTime() å’Œ exponentialRampToValueAtTime()ã€‚ä¸¤è€…çš„åŒºåˆ«åœ¨äºå‘ç”Ÿå˜æ¢çš„æ–¹å¼ã€‚åœ¨ä¸€äº›ç”¨ä¾‹ä¸­ï¼Œexponential å˜æ¢æ›´åŠ æ•æ„Ÿï¼Œå› ä¸ºæˆ‘ä»¬ä»¥æŒ‡æ•°æ–¹å¼æ„ŸçŸ¥å£°éŸ³çš„è®¸å¤šæ–¹é¢ã€‚

è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªä¾‹å­æ¥å±•ç¤ºäº¤å‰å˜æ¢å§ã€‚ç»™å®šä¸€ä¸ªæ’­æ”¾åˆ—è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨éŸ³è½¨é—´å®‰æ’å˜æ¢é™ä½å½“å‰æ’­æ”¾çš„éŸ³è½¨éŸ³é‡å¹¶ä¸”å¢åŠ ä¸‹ä¸€æ¡éŸ³è½¨çš„éŸ³é‡ã€‚ä¸¤è€…éƒ½å‘ç”Ÿåœ¨å½“å‰æ›²ç›®ç»“æŸæ’­æ”¾ä¹‹å‰ç¨æ—©çš„æ—¶å€™ï¼š

```
function createSource(buffer) {
  var source = context.createBufferSource(); 
  var gainNode = context.createGainNode(); 
  source.buffer = buffer;
  // Connect source to gain. source.connect(gainNode);
  // Connect gain to destination. gainNode.connect(context.destination);
  return {
    source: source, gainNode: gainNode
  }; 
}

function playHelper(buffers, iterations, fadeTime) { 
  var currTime = context.currentTime;
  for (var i = 0; i < iterations; i++) {
    // For each buffer, schedule its playback in the future.
    for (var j = 0; j < buffers.length; j++) { 
      var buffer = buffers[j];
      var duration = buffer.duration;
      var info = createSource(buffer);
      var source = info.source;
      var gainNode = info.gainNode;
      // æ¸å…¥
      gainNode.gain.linearRampToValueAtTime(0, currTime); 
      gainNode.gain.linearRampToValueAtTime(1, currTime + fadeTime);
      // æ¸å‡º
      gainNode.gain.linearRampToValueAtTime(1, currTime + duration-fadeTime);
      gainNode.gain.linearRampToValueAtTime(0, currTime + duration);
      // æ’­æ”¾å½“å‰éŸ³é¢‘.
      source.noteOn(currTime);
      // ä¸ºä¸‹æ¬¡è¿­ä»£ç´¯åŠ æ—¶é—´
      currTime += duration - fadeTime;
    }
  } 
}


```


## Custom Timing Curves
If neither a linear nor an exponential curve satisfies your needs, you can also specify your own value curve via an array of values using the setValueCurveAtTime function. With this function, you can define a custom timing curve by providing an array of timing values. Itâ€™s a shortcut for making a bunch of setValueAtTime calls, and should be used in this case. For example, if we want to create a tremolo(é¢¤éŸ³) effect, we can apply an oscillating curve to the gain AudioParam of a GainNode, as in Figure 2-2.

The oscillating curve in the previous figure could be implemented with the following code:


In the previous snippet, weâ€™ve manually computed a sine curve and applied it to the gain parameter to create a tremolo sound effect. It took a bit of math, though.

This brings us to a very nifty feature of the Web Audio API that lets us build effects like tremolo more easily. We can take any audio stream that would ordinarily be conâ€ nected into another AudioNode, and instead connect it into any AudioParam. This important idea is the basis for many sound effects. The previous code is actually an example of such an effect called a low frequency oscillator (LFO) applied to the gain, which is used to build effects such as vibrato, phasing, and tremolo. By using the oscillator node [see â€œOscillator-Based Direct Sound Synthesisâ€ on page 34], we can easily rebuild the previous example as follows:

## å®šåˆ¶æ—¶é—´æ›²çº¿

å¦‚æœçº¿æ€§æ›²çº¿å’ŒæŒ‡æ•°æ›²çº¿éƒ½æ— æ³•æ»¡è¶³ä½ çš„éœ€æ±‚ï¼Œä½ ä¹Ÿå¯ä»¥è‡ªå·±å®šåˆ¶è‡ªå·±çš„æ›²çº¿å€¼é€šè¿‡ä¼ é€’ä¸€ä¸ªæ•°ç»„ç»™ setValueCurveAtTime å‡½æ•°å®ç°ã€‚æœ‰äº†è¿™ä¸ªå‡½æ•°ï¼Œä½ å¯ä»¥é€šè¿‡ä¼ é€’æ•°ç»„å®ç°è‡ªå®šä¹‰æ—¶é—´æ›²çº¿ã€‚å®ƒæ˜¯åˆ›å»ºä¸€å † setValueAtTime å‡½æ•°è°ƒç”¨çš„å¿«æ·è°ƒç”¨ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åˆ›å»ºé¢¤éŸ³æ•ˆæœï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¼ é€’æŒ¯è¡æ›²çº¿ä½œä¸º GainNode çš„ gain å‚æ•°å€¼ï¼Œå¦‚å›¾ 2-2

![images](./ch02/img/2-2.png)

ä¸Šå›¾çš„æŒ¯è¡æ›²çº¿å®ç°ä»£ç å¦‚ä¸‹ï¼š

```

var DURATION = 2; 
var FREQUENCY = 1; 
var SCALE = 0.4;
    // Split the time into valueCount discrete steps.
var valueCount = 4096;
// Create a sinusoidal value curve.
var values = new Float32Array(valueCount); 
for (var i = 0; i < valueCount; i++) {
  var percent = (i / valueCount) * DURATION*FREQUENCY;
  values[i] = 1 + (Math.sin(percent * 2*Math.PI) * SCALE);
  // Set the last value to one, to restore playbackRate to normal at the end. 
  if (i == valueCount - 1) {
    values[i] = 1;
  }
}
// Apply it to the gain node immediately, and make it last for 2 seconds.
this.gainNode.gain.setValueCurveAtTime(values, context.currentTime, DURATION);
```


This brings us to a very nifty feature of the Web Audio API that lets us build effects like tremolo more easily. We can take any audio stream that would ordinarily be connected into another AudioNode, and instead connect it into any AudioParam. This important idea is the basis for many sound effects. The previous code is actually an example of such an effect called a low frequency oscillator (LFO) applied to the gain, which is used to build effects such as vibrato, phasing, and tremolo. By using the oscillator node [see â€œOscillator-Based Direct Sound Synthesisâ€ on page 34], we can easily rebuild the previous example as follows:


The latter approach is more efficient than creating a custom value curve and saves us from having to compute sine functions manually by creating a loop to repeat the effect.

ä¸Šé¢çš„ä»£ç ç‰‡æ–­æˆ‘ä»¬æ‰‹åŠ¨è®¡ç®—å‡ºäº†æ­£å¼¦æ›²çº¿å¹¶å°†å…¶è®¾ç½®åˆ° gain çš„å‚æ•°å†…åˆ›é€ å‡ºé¢¤éŸ³æ•ˆæœã€‚å¥½å§ï¼Œå®ƒç”¨äº†ä¸€ç‚¹ç‚¹æ•°å­¦..

è¿™ç»™æˆ‘ä»¬å¸¦æ¥äº† Web Audio API çš„ä¸€ä¸ªéå¸¸é‡è¦çš„ç‰¹æ€§, å®ƒä½¿å¾—æˆ‘ä»¬åˆ›å»ºåƒé¢¤éŸ³è¿™æ ·çš„ç‰¹æ•ˆå˜çš„éå¸¸å®¹æ˜“ã€‚è¿™ä¸ªé‡è¦çš„ç‚¹å­æ˜¯å¾ˆå¤šéŸ³é¢‘ç‰¹æ•ˆçš„åŸºç¡€ã€‚ä¸Šè¿°çš„ä»£ç å®é™…ä¸Šæ˜¯è¢«ç§°ä¸ºä½é¢‘æŒ¯è¡(LFO)æ•ˆæœåº”ç”¨çš„ä¸€ä¸ªä¾‹å­ï¼Œ LFO ç»å¸¸ç”¨äºåˆ›å»ºç‰¹æ•ˆï¼Œå¦‚ vibrato éœ‡åŠ¨ phasing åˆ†é˜Ÿ å’Œ tremolo é¢¤éŸ³ã€‚é€šè¿‡å¯¹éŸ³é¢‘èŠ‚ç‚¹åº”ç”¨æŒ¯è¡ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“é‡å†™ä¹‹å‰çš„ä¾‹å­ï¼š

```
/ Create oscillator.
var osc = context.createOscillator(); 
osc.frequency.value = FREQUENCY;
var gain = context.createGain(); 
gain.gain.value = SCALE; 
osc.connect(gain); 
gain.connect(this.gainNode.gain);
// Start immediately, and stop in 2 seconds.
osc.start(0);
osc.stop(context.currentTime + DURATION);
```


ç›¸æ¯”äºæˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„è‡ªå®šä¹‰æ›²çº¿åé¢çš„ä»£ç è¦æ›´é«˜æ•ˆï¼Œé‡ç°äº†æ•ˆæœä½†å®ƒå¸®æˆ‘ä»¬çœäº†ç”¨æ‰‹åŠ¨å¾ªç¯åˆ›å»ºæ­£å¼¦å‡½æ•°






















